#include "stdafx.h"
#include <iostream>
#include <string>
#include <ctime>
#include <cassert>

// Fill ends up like this: (a)d1(a')d2(a)d3(a')d..., where
// (a)            = the input sequence
// (a')           = the reversed and inverted input sequence
// d1, d2, d3,... = spacer digits generated by another dragon curve
//
// Note that the sequence of spacer digits is simply what the modified
// dragon curve generates on an input of "0". So to save on space (and
// time) complexity, no need to generate the entire fill length; we
// can just write a class that looks like a filled-up disk.

class FilledDiskWithModifiedDragonCurve
{
public:
    FilledDiskWithModifiedDragonCurve(const std::string &input) :
        input(input), cyclePeriod(2 * input.length() + 2)
    {
    }

    char operator[](unsigned index)
    {
        unsigned offset = index % cyclePeriod;

        if (offset < input.length())
            return input[offset];
        if (offset > input.length() && offset < cyclePeriod - 1)
            return (input[cyclePeriod - offset - 2] == '1') ? '0' : '1';

        unsigned cycle = index / cyclePeriod;
        return zeroCurve[cycle + cycle + ((offset == input.length()) ? 0 : 1)];
    }

private:
    const std::string input;
    const unsigned cyclePeriod;
    static FilledDiskWithModifiedDragonCurve zeroCurve;
};

FilledDiskWithModifiedDragonCurve FilledDiskWithModifiedDragonCurve::zeroCurve("0");

// For the checksum computation, we know how many bits from the filled-up disk
// contribute to each checksum digit (call this "group size").

unsigned ComputeGroupSize(unsigned fillSize)
{
    // Round up to even length
    auto temp = fillSize;
    temp += (temp & 0x1);

    // Eliminate all the zeros on the right (all the factors of 2)
    while ((temp & 0x1) == 0)
        temp >>= 1;

    return fillSize / temp;
}

std::string FindChecksum(FilledDiskWithModifiedDragonCurve &dcg, unsigned fillSize)
{
    auto groupSize = ComputeGroupSize(fillSize);

    std::string cs;
    unsigned oneCount = 0;

    for (auto i = 0U; i < fillSize; i++)
    {
        if (dcg[i] == '1') oneCount++;

        // Emit checksum digit if time to (end of group or end of input)
        if (((i + 1) % groupSize == 0) || (i + 1) == fillSize)
        {
            cs.push_back((oneCount & 0x1) ? '0' : '1');
            oneCount = 0;
        }
    }

    return cs;
}

int main()
{
    double startTime = clock();

    FilledDiskWithModifiedDragonCurve filledDisk("10011111011011001");

    auto part1 = FindChecksum(filledDisk, 272);
    std::cout << "Part One: " << part1 << std::endl;

    auto part2 = FindChecksum(filledDisk, 35651584);
    std::cout << "Part Two: " << part2 << std::endl;

    std::cout << std::endl << "It took " << (clock() - startTime) / (CLOCKS_PER_SEC) << " seconds." << std::endl;

    assert(part1 == "10111110010110110");
    assert(part2 == "01101100001100100");
    return 0;
}
