#include "stdafx.h"
#include <iostream>
#include <string>
#include <algorithm>
#include <ctime>
#include <cassert>

using namespace std::string_literals;

// Fill ends up like this: (a)d1(a')d2(a)d3(a')d..., where
// (a)            = the input sequence
// (a')           = the reverse and inverted input sequence
// d1, d2, d3,... = spacer digits generated by the dragon curve
//
// Note that the sequence of spacer digits is simply what the modified
// dragon curve generates on an input of "0".

void ApplyModifiedDragonCurve(std::string &a)
{
    a.push_back('0');

    for (int i = a.length() - 2; i >= 0; i--)
        a.push_back((a[i] == '1') ? '0' : '1');
}

std::string FillDisk(std::string initialState, unsigned diskLength)
{
    initialState.reserve(diskLength);

    while (initialState.length() < diskLength)
        ApplyModifiedDragonCurve(initialState);

    return initialState.substr(0, diskLength);
}

unsigned ComputeGroupSize(const std::string &s)
{
    // Round up to even length
    auto temp = s.length();
    temp += (temp & 0x1);

    // Eliminate all the zeros on the right (all the factors of 2)
    while ((temp & 0x1) == 0)
        temp >>= 1;

    return s.length() / temp;
}

std::string FindChecksum(const std::string &s)
{
    auto groupSize = ComputeGroupSize(s);

    std::string cs;
    unsigned oneCount = 0;

    for (auto i = 0U; i < s.length(); i++)
    {
        if (s[i] == '1') oneCount++;

        // Emit checksum digit if time to (end of group or end of input)
        if (((i + 1) % groupSize == 0) || (i + 1) == s.length())
        {
            cs.push_back((oneCount & 0x1) ? '0' : '1');
            oneCount = 0;
        }
    }

    return cs;
}

int main()
{
    double startTime = clock();

    const auto input = "10011111011011001"s;

    auto fill = FillDisk(input, 272);
    auto part1 = FindChecksum(fill);
    std::cout << "Part One: " << part1 << std::endl;

    fill = FillDisk(input, 35651584);
    auto part2 = FindChecksum(fill);
    std::cout << "Part Two: " << part2 << std::endl;

    std::cout << std::endl << "It took " << (clock() - startTime) / (CLOCKS_PER_SEC / 1000) << " ms." << std::endl;

    assert(part1 == "10111110010110110");
    assert(part2 == "01101100001100100");
    return 0;
}
